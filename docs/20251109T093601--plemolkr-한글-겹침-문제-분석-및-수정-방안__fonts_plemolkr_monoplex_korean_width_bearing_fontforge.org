#+title:      PlemolKR 한글 겹침 문제 분석 및 수정 방안
#+date:       [2025-11-09 Sat 09:36]
#+filetags:   :fonts:plemolkr:monoplex:korean:width:bearing:fontforge:
#+identifier: 20251109T093601
#+export_file_name: 20251109T093601.md

* 문서 개요 :ANALYSIS:

본 문서는 PlemolKR 폰트에서 발생하는 한글 겹침 문제를 분석하고,
Monoplex 폰트와의 비교를 통해 근본 원인을 파악하며,
수정 방안과 잠재적 side-effect를 검토합니다.

** 작성 배경

- 이슈: https://github.com/soomtong/PlemolKR/issues/1
- 환경: Linux + Emacs
- 현상: 한글 텍스트가 우측에서 겹쳐 보임
- 기존 Monoplex Nerd는 정상 작동

** 목표

1. 리눅스/터미널/이맥스 환경 최적화
2. macOS/Windows에서도 호환성 유지
3. TUI 환경에서 최적의 폰트 제공
4. 전체 유니코드 세트(한글, 수식, 이모지) 정확한 렌더링

* 프로젝트 개요 :BACKGROUND:

** PlemolKR 프로젝트

PlemolKR는 PlemolJP의 한글 버전 포크입니다.

*** 폰트 구성
- 영문/ASCII: IBM Plex Mono (monospace)
- 한글: IBM Plex Sans KR
- 일본어: IBM Plex Sans JP (레거시)
- 추가 글리프: Hack font
- 선택적: Nerd Fonts

*** 빌드 시스템
- Stage 1 (fontforge_script.py): 폰트 병합 + 글리프 조작
- Stage 2 (fonttools_script.py): 힌팅 + 최종 처리

*** 폰트 패밀리
1. PlemolKR - 1:2 비율 (528:1056)
2. PlemolKRConsole - 콘솔 최적화
3. PlemolKR35 - 3:5 비율 (600:1000)
4. PlemolKR35Console - 3:5 + 콘솔

** Monoplex 프로젝트

Monoplex KR은 IBM Plex Mono + IBM Plex Sans KR의 직접 병합입니다.

*** 주요 특징
- PlemolJP 빌드 스크립트 기반
- Shell script (bash) 기반 빌드
- FontForge 내장 함수 활용 (CenterInWidth)
- 정확한 width/bearing 처리

*** 폰트 패밀리
1. Monoplex KR - 1:2 비율
2. Monoplex KR Nerd - Nerd Fonts 포함
3. Monoplex KR Wide - 3:5 비율
4. Monoplex KR Wide Nerd - 3:5 + Nerd Fonts

* 문제 분석 :ISSUE:

** 한글 겹침 현상

*** 관찰된 증상
- 환경: Linux + Emacs
- 현상: 한글 문자가 우측에서 겹쳐 보임
- 스크린샷: https://github.com/soomtong/PlemolKR/issues/1#issuecomment-3507179093

*** 재현 조건
- PlemolKR 폰트 사용 시
- Monoplex Nerd는 정상 작동
- 특정 렌더러(Emacs, 일부 터미널)에서 발생

** 근본 원인 분석

*** IBM Plex Sans KR의 실제 폰트 메트릭

#+BEGIN_SRC python
import fontforge
kr = fontforge.open('source/IBM-Plex-Sans-KR/unhinted/IBMPlexSansKR-Regular.ttf')

# 한글 글리프 width 확인
U+AC00 (가): width=892
U+AC01 (각): width=892
U+AC04 (간): width=892
U+D7A3 (힣): width=892
#+END_SRC

**핵심**: IBM Plex Sans KR 한글 글리프의 실제 width는 *892*입니다.

*** PlemolKR의 잘못된 가정

fontforge_script.py의 문제:

**** 1단계: set_width_600_or_1000 (709-734줄)

#+BEGIN_SRC python
def set_width_600_or_1000(jp_font):
    """반각폭 또는 전각폭으로 변환"""
    for glyph in jp_font.glyphs():
        # 한글 글리프 (width=892)가 여기 해당
        if 500 < glyph.width < 1000:
            # 1000폭으로 가정하고 중앙 정렬
            glyph.transform(psMat.translate((1000 - glyph.width) / 2, 0))
            # 실제: (1000 - 892) / 2 = 54 픽셀 우측 이동
            glyph.width = 1000
#+END_SRC

*문제점*: 한글 글리프를 1000 width로 강제 변환하면서 54픽셀 이동

**** 2단계: transform_half_width (771-801줄)

#+BEGIN_SRC python
def transform_half_width(jp_font, eng_font):
    """1:2 비율로 변환"""
    after_width_eng = 528  # HALF_WIDTH_12

    for glyph in jp_font.glyphs():
        if glyph.width == 1000:
            # 전각은 528*2 = 1056으로 변환
            glyph.transform(psMat.translate((1056 - 1000) / 2, 0))
            # 추가로 28픽셀 우측 이동
            glyph.width = 1056
#+END_SRC

*문제점*: 다시 28픽셀 이동 (총 82픽셀 이동)

*** 총 변환 과정

#+BEGIN_EXAMPLE
[IBM Plex Sans KR]
width: 892
left bearing: X
right bearing: Y

→ [1단계] set_width_600_or_1000
width: 1000
translate: +54
left bearing: X + 54
right bearing: Y - 54 (실제로는 width만 변경)

→ [2단계] transform_half_width
width: 1056
translate: +28
left bearing: X + 54 + 28 = X + 82
right bearing: 계산 안맞음 (겹침 발생!)
#+END_EXAMPLE

*핵심 문제*:
- translate만 사용하고 bearing을 고려하지 않음
- 892 → 1000 → 1056 과정에서 bearing이 깨짐
- 일부 렌더러는 이를 제대로 처리하지 못함

** Monoplex의 올바른 처리

monoplex_kr_generator.sh (1035-1160줄):

#+BEGIN_SRC bash
# 전각 width 설정
plexkr_width=892  # 실제 KR 폰트 width
monoplex_kr_full_width=1056  # 목표 width

move_pt = $(((${monoplex_kr_full_width} - ${plexkr_width}) / 2))
# move_pt = (1056 - 892) / 2 = 82

width_pt = ${monoplex_kr_full_width}

# 글리프 선택 후
Move(move_pt, 0)      # 82픽셀 이동
SetWidth(width_pt)    # 1056으로 설정
CenterInWidth()       # ★ 핵심: bearing 자동 조정
#+END_SRC

*차이점*:
1. 실제 width 892를 정확히 인식
2. 한 번에 1056으로 변환 (중간 단계 없음)
3. *CenterInWidth()* 내장 함수로 bearing 자동 조정

*** CenterInWidth() 함수의 역할

FontForge 내장 함수로, 글리프를 width 내에서 정확히 중앙 정렬합니다:

#+BEGIN_EXAMPLE
CenterInWidth() 동작:
1. 글리프의 실제 bounding box 계산
2. left bearing = (width - bbox_width) / 2
3. right bearing = (width - bbox_width) / 2
4. 정확한 중앙 정렬 보장
#+END_EXAMPLE

* 기술적 깊이 분석 :TECHNICAL:

** 폰트 메트릭 개념

*** Width (폭)
- 글리프가 차지하는 수평 공간
- 다음 글리프까지의 거리 (advance width)

*** Bearing (베어링)
- Left bearing (LSB): 글리프 시작점에서 실제 잉크까지의 거리
- Right bearing (RSB): 실제 잉크에서 width 끝까지의 거리

*** 관계식
#+BEGIN_EXAMPLE
width = left_bearing + glyph_actual_width + right_bearing
#+END_EXAMPLE

** PlemolKR의 문제를 수식으로 표현

*** 초기 상태 (IBM Plex Sans KR)
#+BEGIN_EXAMPLE
width₀ = 892
LSB₀ = a
RSB₀ = b
actual_width = 892 - a - b
#+END_EXAMPLE

*** 1단계: set_width_600_or_1000
#+BEGIN_EXAMPLE
translate: +54
width₁ = 1000

# translate는 LSB만 변경
LSB₁ = a + 54
actual_width = 변경 없음 (892 - a - b)
RSB₁ = width₁ - LSB₁ - actual_width
     = 1000 - (a + 54) - (892 - a - b)
     = 1000 - a - 54 - 892 + a + b
     = 54 + b

# 검증
LSB₁ + actual_width + RSB₁
= (a + 54) + (892 - a - b) + (54 + b)
= 1000 ✓
#+END_EXAMPLE

*** 2단계: transform_half_width
#+BEGIN_EXAMPLE
translate: +28
width₂ = 1056

LSB₂ = (a + 54) + 28 = a + 82
actual_width = 변경 없음
RSB₂ = 1056 - (a + 82) - (892 - a - b)
     = 1056 - a - 82 - 892 + a + b
     = 82 + b

# 검증
LSB₂ + actual_width + RSB₂
= (a + 82) + (892 - a - b) + (82 + b)
= 1056 ✓
#+END_EXAMPLE

*** Monoplex의 올바른 처리
#+BEGIN_EXAMPLE
width = 1056
Move(82, 0)
SetWidth(1056)
CenterInWidth()

# CenterInWidth() 결과
actual_width = 892 - a - b (변경 없음)
LSB_final = (1056 - actual_width) / 2
          = (1056 - (892 - a - b)) / 2
          = (164 + a + b) / 2
RSB_final = (1056 - actual_width) / 2
          = (164 + a + b) / 2

# 완벽한 중앙 정렬
LSB_final = RSB_final
#+END_EXAMPLE

** 문제의 핵심

PlemolKR:
- LSB₂ = a + 82
- RSB₂ = b + 82
- 원본 bearing의 비대칭성 (a ≠ b)이 그대로 유지됨
- 82픽셀 우측 이동으로 인해 비대칭이 더 심화

Monoplex:
- LSB_final = RSB_final = (164 + a + b) / 2
- 원본 bearing과 무관하게 완벽한 대칭
- 모든 렌더러에서 일관된 결과

* 수정 방안 :SOLUTION:

** 방안 1: CenterInWidth() 사용 (권장)

fontforge_script.py 수정:

#+BEGIN_SRC python
def transform_half_width(jp_font, eng_font):
    """1:2 비율로 변환 (개선 버전)"""
    after_width_eng = HALF_WIDTH_12  # 528

    for glyph in jp_font.glyphs():
        if glyph.width == 600:
            # 반각
            glyph.width = after_width_eng
            glyph.transform(psMat.translate(
                (after_width_eng - glyph.width) / 2, 0))
            glyph.width = after_width_eng
        elif glyph.width == 1000:
            # 전각 - bearing 자동 조정
            target_width = after_width_eng * 2  # 1056
            glyph.width = target_width
            # ★ 핵심: 중앙 정렬 함수 사용
            # Python API: glyph.center_in_width()
            # 또는 직접 계산:
            bbox = glyph.boundingBox()
            actual_width = bbox[2] - bbox[0]
            offset = (target_width - actual_width) / 2 - bbox[0]
            glyph.transform(psMat.translate(offset, 0))
            glyph.width = target_width
#+END_SRC

*장점*:
- 정확한 bearing 조정
- Monoplex와 동일한 결과
- 모든 렌더러에서 일관성

*단점*:
- 기존 로직 변경 필요

** 방안 2: 2단계 변환 제거

더 근본적인 해결:

#+BEGIN_SRC python
def set_width_and_transform(jp_font):
    """한 번에 올바른 width로 변환"""
    ACTUAL_KR_WIDTH = 892  # IBM Plex Sans KR 실제 width
    HALF_WIDTH = 528
    FULL_WIDTH = 1056

    for glyph in jp_font.glyphs():
        # 한글 범위 (0xAC00-0xD7A3 등)
        if 0xAC00 <= glyph.unicode <= 0xD7A3:
            # 실제 width 기준으로 변환
            bbox = glyph.boundingBox()
            actual_width = bbox[2] - bbox[0]
            offset = (FULL_WIDTH - actual_width) / 2 - bbox[0]
            glyph.transform(psMat.translate(offset, 0))
            glyph.width = FULL_WIDTH
        # 기타 로직...
#+END_SRC

*장점*:
- 중간 단계 없이 직접 변환
- 더 명확한 로직
- 성능 향상 (1회 변환)

*단점*:
- 전체 리팩토링 필요
- 테스트 범위 증가

** 방안 3: Monoplex 스크립트 차용

PlemolKR를 Monoplex 방식으로 재작성:

*장점*:
- 검증된 로직 사용
- Monoplex와 완전 호환

*단점*:
- Python → Bash 전환
- 유지보수 어려움

* Side-effect 고려사항 :RISKS:

** 플랫폼별 영향

*** Linux
- 현재: 문제 발생
- 수정 후: 개선 예상
- 리스크: 낮음

*** macOS
- 현재: 상태 불명 (테스트 필요)
- 수정 후: bearing 정확성 향상
- 리스크: 중간 (일부 앱에서 spacing 변화 가능)

*** Windows
- 현재: 상태 불명
- 수정 후: 렌더링 개선 예상
- 리스크: 중간 (ClearType 힌팅 영향)

** 렌더러별 영향

*** Emacs
- 현재: 겹침 발생
- 수정 후: 해결 예상
- 리스크: 낮음

*** VSCode
- 현재: 상태 불명
- 수정 후: 일관성 향상
- 리스크: 낮음 (이미 bearing 기반 렌더링)

*** 터미널 (Alacritty, Kitty, etc.)
- 현재: 문제 가능성
- 수정 후: 개선
- 리스크: 낮음~중간 (터미널마다 다름)

** 기존 사용자 영향

*** 시각적 변화
- 한글 글리프가 약간 좌측으로 이동 (더 중앙 정렬)
- spacing이 균일해짐
- 일부 사용자는 "다르게 보인다"고 느낄 수 있음

*** 호환성
- 폰트 메트릭 변경으로 line height 영향 가능성
- 기존 설정된 폰트 크기 재조정 필요 가능
- PDF/문서 출력 시 layout 변화 가능

** 다른 글리프에 미치는 영향

*** 일본어
- 동일한 로직 적용
- IBM Plex Sans JP도 width 확인 필요
- 테스트 필요

*** 기호/심볼
- 이미 별도 처리
- 영향 낮음

*** Nerd Fonts
- 반각 처리
- 영향 없음

* 테스트 계획 :TESTING:

** 단위 테스트

*** width 검증
#+BEGIN_SRC python
def test_korean_glyph_width():
    font = fontforge.open('build/PlemolKR-Regular.ttf')
    for code in range(0xAC00, 0xD7A4):  # 한글 음절
        if code in font:
            glyph = font[code]
            assert glyph.width == 1056, f"U+{code:04X} width={glyph.width}"
    font.close()
#+END_SRC

*** bearing 검증
#+BEGIN_SRC python
def test_korean_glyph_bearing():
    font = fontforge.open('build/PlemolKR-Regular.ttf')
    for code in range(0xAC00, 0xD7A4):
        if code in font:
            glyph = font[code]
            bbox = glyph.boundingBox()
            lsb = bbox[0]
            rsb = glyph.width - bbox[2]
            # 중앙 정렬 허용 오차 ±5
            assert abs(lsb - rsb) < 5, \
                f"U+{code:04X} LSB={lsb} RSB={rsb}"
    font.close()
#+END_SRC

** 통합 테스트

*** 시각적 테스트
1. 샘플 텍스트 렌더링
2. 스크린샷 비교 (before/after)
3. 다양한 크기에서 테스트 (10pt, 12pt, 14pt, 16pt)

*** 플랫폼별 테스트
- [ ] Linux + Emacs
- [ ] Linux + VSCode
- [ ] Linux + Alacritty
- [ ] macOS + Terminal
- [ ] macOS + iTerm2
- [ ] Windows + Windows Terminal

*** 렌더링 엔진별 테스트
- [ ] FreeType
- [ ] HarfBuzz
- [ ] DirectWrite (Windows)
- [ ] Core Text (macOS)

** 회귀 테스트

*** 기존 기능 검증
- [ ] 영문 폰트 정상 작동
- [ ] 일본어 폰트 정상 작동
- [ ] Nerd Fonts 아이콘 표시
- [ ] 합자(ligature) 동작
- [ ] Console 모드 동작
- [ ] 3:5 비율 폰트 동작

* 구현 로드맵 :ROADMAP:

** Phase 1: 분석 및 검증 (완료)
- [X] 문제 원인 파악
- [X] Monoplex 비교 분석
- [X] IBM Plex Sans KR width 확인
- [X] 기술 문서 작성

** Phase 2: 수정 구현 (진행 중)
- [ ] fontforge_script.py 수정
- [ ] 단위 테스트 작성
- [ ] Quick build로 검증
- [ ] 전체 빌드 테스트

** Phase 3: 검증 및 테스트
- [ ] Linux 환경 테스트
- [ ] macOS 환경 테스트 (가능 시)
- [ ] Windows 환경 테스트 (가능 시)
- [ ] 시각적 비교 문서 작성

** Phase 4: PR 제출
- [ ] 코드 리뷰 준비
- [ ] 커밋 메시지 작성
- [ ] PR 설명 작성
- [ ] Before/After 스크린샷 첨부

* 참고자료 :REFERENCES:

** 이슈 및 저장소
- Original Issue: https://github.com/soomtong/PlemolKR/issues/1
- PlemolKR: https://github.com/soomtong/PlemolKR
- Monoplex: https://github.com/y-kim/monoplex
- PlemolJP: https://github.com/yuru7/PlemolJP
- IBM Plex: https://github.com/IBM/plex

** 기술 문서
- FontForge Python API: https://fontforge.org/docs/scripting/python.html
- Font Metrics: https://developer.mozilla.org/en-US/docs/Web/CSS/font-feature-settings
- TrueType Specification: https://learn.microsoft.com/en-us/typography/opentype/spec/

** 관련 폰트 프로젝트
- Sarasa Gothic: https://github.com/be5invis/Sarasa-Gothic
- Iosevka: https://github.com/be5invis/Iosevka
- Hack: https://github.com/source-foundry/Hack
- Nerd Fonts: https://github.com/ryanlmcintyre/nerd-fonts

* 결론 :CONCLUSION:

** 핵심 발견

1. *문제의 본질*: PlemolKR는 IBM Plex Sans KR의 실제 width(892)를
   1000으로 가정하여 처리하면서 bearing이 부정확해짐

2. *Monoplex의 우수성*: CenterInWidth() 내장 함수를 사용하여
   bearing을 정확히 조정

3. *해결 방안*: bearing을 고려한 중앙 정렬 알고리즘 적용

** 권장 조치

1. *즉시 수정*: transform_half_width 함수에 bearing 조정 로직 추가
2. *장기 개선*: 2단계 변환을 1단계로 통합하여 코드 간소화
3. *테스트 강화*: 플랫폼별, 렌더러별 회귀 테스트 자동화

** 기대 효과

- Linux/Emacs 환경에서 한글 겹침 문제 해결
- 모든 플랫폼에서 일관된 렌더링
- TUI 환경에서 최적의 한글 폰트 경험
- 향후 유니코드 확장 시 안정적인 기반 확보

---

본 문서는 PlemolKR 폰트 개선 프로젝트의 기술 분석 문서입니다.
수정 사항은 fix/korean-overlap 브랜치에서 진행됩니다.

#+BEGIN_EXAMPLE
Repository: /home/goqual/repos/gh/PlemolKR
Branch: fix/korean-overlap
Date: 2025-11-09
Analyzer: Claude Code + junghanacs
#+END_EXAMPLE
